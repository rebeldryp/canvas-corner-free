[
  {
    "projectId": "bff647fd-eaa5-4022-bbf2-e99d2bfa2f1a",
    "testId": "631d1a18-d7e1-4498-9799-8ec37c26818b",
    "userId": "747864b8-9041-7032-2825-9559f78cf090",
    "title": "TC001-Admin access granted to owner email",
    "description": "Verify that only the user with the owner email can access admin routes when Supabase is enabled.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8082\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Ensure environment variable VITE_SUPABASE_ENABLED is true\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Verify environment variable VITE_SUPABASE_ENABLED is true and user is authenticated with owner email\n        await page.goto('http://localhost:8082/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input owner email and password, then click Sign In\n        frame = context.pages[-1]\n        # Input owner email\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input owner password\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Templates link to verify access to /admin/templates\n        frame = context.pages[-1]\n        # Click Templates link to navigate to /admin/templates\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Analytics link to verify access to /admin/analytics\n        frame = context.pages[-1]\n        # Click Analytics link to navigate to /admin/analytics\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Settings link to verify access to /admin/settings\n        frame = context.pages[-1]\n        # Click Settings link to navigate to /admin/settings\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Logout button to test logout functionality and then verify access denial for unauthorized users\n        frame = context.pages[-1]\n        # Click Logout button to log out the owner user\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify environment variable VITE_SUPABASE_ENABLED is true\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Admin').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Templates').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Analytics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Settings').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Logout').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Template Management').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Upload and manage template versions and previews').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Analytics').nth(1)).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Downloads and engagement').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Settings').nth(1)).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Limits, CDN, and configuration').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/747864b8-9041-7032-2825-9559f78cf090/176323254940709//tmp/test_task/result.webm",
    "created": "2025-11-15T18:43:28.109Z",
    "modified": "2025-11-15T18:49:09.528Z"
  },
  {
    "projectId": "bff647fd-eaa5-4022-bbf2-e99d2bfa2f1a",
    "testId": "4e2a2249-6158-4406-9d2f-60132613036a",
    "userId": "747864b8-9041-7032-2825-9559f78cf090",
    "title": "TC002-Admin access denied to non-owner emails",
    "description": "Verify that users with emails other than the owner email cannot access any admin routes even when Supabase is enabled.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8082\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check or set environment variable VITE_SUPABASE_ENABLED to true\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Verify environment variable VITE_SUPABASE_ENABLED is true\n        await page.goto('http://localhost:8082/admin/templates', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to /admin/analytics to verify access denial\n        await page.goto('http://localhost:8082/admin/analytics', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to /admin/settings to verify access denial for non-owner user\n        await page.goto('http://localhost:8082/admin/settings', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Verify environment variable VITE_SUPABASE_ENABLED is true to confirm test conditions\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Verify environment variable VITE_SUPABASE_ENABLED is true\n        await page.goto('http://localhost:8082/admin/settings', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Verify environment variable VITE_SUPABASE_ENABLED is true\n        await page.goto('http://localhost:8082', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click Sign In to attempt login as non-owner user\n        frame = context.pages[-1]\n        # Click Sign In button to start login process\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input non-owner user email and password, then click Sign In button\n        frame = context.pages[-1]\n        # Input non-owner user email\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input non-owner user password\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check for logout option in admin header for non-owner user\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Check for logout option in admin header or navigation for non-owner user\n        await page.mouse.wheel(0, -await page.evaluate('() => window.innerHeight'))\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Access denied').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/747864b8-9041-7032-2825-9559f78cf090/1763232545084746//tmp/test_task/result.webm",
    "created": "2025-11-15T18:43:28.161Z",
    "modified": "2025-11-15T18:49:05.236Z"
  },
  {
    "projectId": "bff647fd-eaa5-4022-bbf2-e99d2bfa2f1a",
    "testId": "c9df2203-334f-45de-9442-79804b3e3dbb",
    "userId": "747864b8-9041-7032-2825-9559f78cf090",
    "title": "TC003-Admin access completely disabled when Supabase is not enabled",
    "description": "Verify that no user, including the owner, can access admin routes when environment variable VITE_SUPABASE_ENABLED is false.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8082\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Set environment variable VITE_SUPABASE_ENABLED to false\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Set environment variable VITE_SUPABASE_ENABLED to false\n        await page.goto('http://localhost:8082/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Set environment variable VITE_SUPABASE_ENABLED to false or find login form\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to navigate to /admin/templates and verify access denied or redirect\n        await page.goto('http://localhost:8082/admin/templates', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to navigate to /admin/analytics and verify access denied or redirect\n        await page.goto('http://localhost:8082/admin/analytics', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to navigate to /admin/settings and verify access denied or redirect\n        await page.goto('http://localhost:8082/admin/settings', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Write and save the test report summarizing the verification results\n        await page.goto('http://localhost:8082/admin/logout', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Write and save the test report summarizing the verification results without logout verification\n        await page.goto('http://localhost:8082/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Save the test report by alternative means or complete the task with available information\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Access denied').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/747864b8-9041-7032-2825-9559f78cf090/1763232599892778//tmp/test_task/result.webm",
    "created": "2025-11-15T18:43:28.169Z",
    "modified": "2025-11-15T18:50:00.119Z"
  },
  {
    "projectId": "bff647fd-eaa5-4022-bbf2-e99d2bfa2f1a",
    "testId": "abf5ad40-38ca-408e-8f9f-e98330d982cb",
    "userId": "747864b8-9041-7032-2825-9559f78cf090",
    "title": "TC004-Admin pages enforce guard regardless of user role when Supabase enabled",
    "description": "Verify that all admin feature pages enforce access guard by restricting access only to the owner email user when Supabase is enabled, denying guest or other roles.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8082\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Owner Access Granted').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Admin feature pages did not enforce access guard correctly. Unauthorized users should see 'Access denied' message, but access was incorrectly granted.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:8082/src/index.css?t=1763231943407:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:8082/node_modules/.vite/deps/react-dom_client.js?v=c2648d4a:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:8082/src/App.tsx?t=1763231943407:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/747864b8-9041-7032-2825-9559f78cf090/176323228526205//tmp/test_task/result.webm",
    "created": "2025-11-15T18:43:28.174Z",
    "modified": "2025-11-15T18:44:45.387Z"
  },
  {
    "projectId": "bff647fd-eaa5-4022-bbf2-e99d2bfa2f1a",
    "testId": "f03cce29-30c7-433b-8871-4ba275ac9bd8",
    "userId": "747864b8-9041-7032-2825-9559f78cf090",
    "title": "TC005-Admin pages deny access to unauthenticated users",
    "description": "Verify that unauthenticated users cannot access any admin pages and are redirected to login or shown access denied.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8082\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to access /admin/templates as unauthenticated user or check if there is a navigation element to admin pages.\n        await page.goto('http://localhost:8082/admin/templates', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to access /admin/analytics as unauthenticated user to verify access denial or redirection.\n        await page.goto('http://localhost:8082/admin/analytics', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to access /admin/settings as unauthenticated user to verify access denial or redirection.\n        await page.goto('http://localhost:8082/admin/settings', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to access /admin again or check for login redirection or access denied message.\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to the login page to verify accessibility for unauthenticated users.\n        await page.goto('http://localhost:8082/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input admin email and password, then click Sign In to attempt login.\n        frame = context.pages[-1]\n        # Input admin email\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Templates link to verify access to /admin/templates as authenticated user.\n        frame = context.pages[-1]\n        # Click Templates link to access /admin/templates as authenticated user\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Analytics link to access /admin/analytics as authenticated user.\n        frame = context.pages[-1]\n        # Click Analytics link to access /admin/analytics as authenticated user\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Settings link to access /admin/settings as authenticated user.\n        frame = context.pages[-1]\n        # Click Settings link to access /admin/settings as authenticated user\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Logout button to log out the admin user.\n        frame = context.pages[-1]\n        # Click Logout button to log out the admin user\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to access /admin as unauthenticated user after logout to verify access denial or redirection.\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Access denied').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Logout').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Template Management').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Upload and manage template versions and previews').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Analytics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Downloads and engagement').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Settings').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Limits, CDN, and configuration').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/747864b8-9041-7032-2825-9559f78cf090/17632325889489//tmp/test_task/result.webm",
    "created": "2025-11-15T18:43:28.181Z",
    "modified": "2025-11-15T18:49:49.076Z"
  },
  {
    "projectId": "bff647fd-eaa5-4022-bbf2-e99d2bfa2f1a",
    "testId": "ab91e803-4b07-4179-be6c-c0a2deac9efe",
    "userId": "747864b8-9041-7032-2825-9559f78cf090",
    "title": "TC006-Owner email env variable presence validation",
    "description": "Verify system behavior when OWNER_EMAIL environment variable is missing or empty, ensuring no unintended admin access.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8082\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Unset or clear OWNER_EMAIL environment variable\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Set VITE_SUPABASE_ENABLED environment variable to true\n        await page.goto('http://localhost:8082/settings', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate back to home or login page to authenticate as any user email\n        frame = context.pages[-1]\n        # Click 'Return to Home' link to go back to home page\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Sign In' button to start authentication\n        frame = context.pages[-1]\n        # Click 'Sign In' button to open login form\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/div/nav/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input admin email and password, then click Sign In button\n        frame = context.pages[-1]\n        # Input admin email\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to authenticate\n        elem = frame.locator('xpath=html/body/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to refresh the page to see if the loading state resolves and access status or error message appears\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click Logout button to verify logout functionality is available in admin header\n        frame = context.pages[-1]\n        # Click Logout button to log out from admin\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Write test report summarizing that admin access was granted despite missing OWNER_EMAIL environment variable, indicating a security issue, and logout works as expected.\n        await page.goto('http://localhost:8082/testsprite_tests/testsprite-mcp-test-report.md', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Access denied').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/747864b8-9041-7032-2825-9559f78cf090/176323262971126//tmp/test_task/result.webm",
    "created": "2025-11-15T18:43:28.189Z",
    "modified": "2025-11-15T18:50:29.837Z"
  },
  {
    "projectId": "bff647fd-eaa5-4022-bbf2-e99d2bfa2f1a",
    "testId": "3ea0459f-962b-4efc-9e3d-cf4c7d456006",
    "userId": "747864b8-9041-7032-2825-9559f78cf090",
    "title": "TC007-Case sensitivity check for owner email",
    "description": "Verify that admin access is denied if email case does not exactly match OWNER_EMAIL to ensure case sensitivity in email verification.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8082\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate back to base URL and verify environment variable VITE_SUPABASE_ENABLED is set to true\n        await page.goto('http://localhost:8082/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Set VITE_SUPABASE_ENABLED to true and reload the page\n        await page.goto('http://localhost:8082/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to login page or trigger login to authenticate with case-different email\n        await page.goto('http://localhost:8082/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email with case difference and password, then click Sign In\n        frame = context.pages[-1]\n        # Input email with case difference to test case sensitivity\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for authentication\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to attempt login\n        elem = frame.locator('xpath=html/body/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Logout button to log out from the current session\n        frame = context.pages[-1]\n        # Click Logout button to log out from current session\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input exact OWNER_EMAIL and password, then click Sign In to verify access is granted\n        frame = context.pages[-1]\n        # Input exact OWNER_EMAIL for authentication\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for authentication\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to attempt login\n        elem = frame.locator('xpath=html/body/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Write test report to testsprite_tests/testsprite-mcp-test-report.md summarizing that admin access is not denied for case-different email, indicating case insensitivity in email verification.\n        await page.goto('http://localhost:8082/testsprite_tests/testsprite-mcp-test-report.md', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Access denied').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/747864b8-9041-7032-2825-9559f78cf090/1763232552997897//tmp/test_task/result.webm",
    "created": "2025-11-15T18:43:28.194Z",
    "modified": "2025-11-15T18:49:13.162Z"
  },
  {
    "projectId": "bff647fd-eaa5-4022-bbf2-e99d2bfa2f1a",
    "testId": "af9e3780-3694-4e2c-bb86-209770e433ba",
    "userId": "747864b8-9041-7032-2825-9559f78cf090",
    "title": "TC008-Verify redirect or error UI on access denial",
    "description": "Check that when access is denied for admin pages, the user sees an appropriate error message or is redirected to a safe location.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8082\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to find any navigation or links to login or admin pages by scrolling or checking for hidden elements.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to navigate directly to the admin login page or admin page URL to test access control.\n        await page.goto('http://localhost:8082/admin/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate directly to other known admin pages to verify access denial or redirection behavior for unauthorized users.\n        await page.goto('http://localhost:8082/admin/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to navigate to another admin page or check for logout or error messages in the header or other parts of the site.\n        await page.goto('http://localhost:8082/admin/settings', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find logout or error message in the header or other parts of the site, or try to logout if possible.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to navigate to logout URL or other admin pages to verify access denial or redirection for unauthorized users.\n        await page.goto('http://localhost:8082/logout', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password for admin login and submit to authenticate.\n        frame = context.pages[-1]\n        # Input email for admin login\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for admin login\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teforamokate48@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click sign in button to authenticate as admin user\n        elem = frame.locator('xpath=html/body/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on each admin page link (Templates, Analytics, Settings) to verify if access denial message or redirection occurs for unauthorized users.\n        frame = context.pages[-1]\n        # Click on Templates admin page link\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Analytics admin page link to verify access denial or redirection for unauthorized users.\n        frame = context.pages[-1]\n        # Click on Analytics admin page link\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Settings admin page link to verify access denial or redirection for unauthorized users.\n        frame = context.pages[-1]\n        # Click on Settings admin page link\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click logout button to log out from admin session.\n        frame = context.pages[-1]\n        # Click logout button to log out from admin session\n        elem = frame.locator('xpath=html/body/div/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password for non-owner user login and submit to authenticate.\n        frame = context.pages[-1]\n        # Input email for non-owner user login\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('nonowner@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for non-owner user login\n        elem = frame.locator('xpath=html/body/div/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click sign in button to authenticate as non-owner user\n        elem = frame.locator('xpath=html/body/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Invalid login credentials').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign In').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Create Account').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign Out').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=After signing in, visit /admin').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/747864b8-9041-7032-2825-9559f78cf090/1763232589811476//tmp/test_task/result.webm",
    "created": "2025-11-15T18:43:28.199Z",
    "modified": "2025-11-15T18:49:49.972Z"
  }
]
